#USAGE_BEGIN#traliva_kit_debug##
registerHelp('$LargeTextEdit', {
    title: 'Редактор больших текстов (с динамической подгрузкой). Сохранение изменений в тексте - внешнее.',
    descr: 'Указывается API-функции взаимодействия с сервером, отдающим текст частями. Текст запрашивается по идентификатору текста (в один редактор могут быть загружены разные тексты) и идентификатору фрагмента (текст разбивается на фрагменты, чтобы загружаться частями). Каждый фрагмент разбивается на блоки. Когда пользователь редактирует текст, он редактирует лишь один блок (он идентифицируется парой <идентификатор фрагмента>-<идентификатор блока в фрагменте>). И изменения в тексте представляются лишь теми (фрагмент, блок)ами, текст в которых изменился.\nПри изменении текста меняется его размер, всвязи с чем, возможно, понадобится переразбиение по блокам, а может быть, и по фрагментам. Это должен производить внешний "сохраняльщик". Для этого данный компонент предоставляет лишь API внесения изменений, а также функцию запроса данных в фрагменте().\nОтображение текста - отрендеренный HTML, тегов вы не увидете. Редактирование текста - сырой HTML со всеми тегами.',
//\nОжидаемый формат данных на запрашиваемом URL-е:\n<базовый URL>/<номер фрагмента> --GET--> [\'Первый блок (это HTML-код)\', \'Второй блок (это HTML-код)\']\n<базовый URL> --GET--> ... не запрашивается, так что можете здесь выдавать нужный вам данные, или давать ERROR_404, если вам этот адрес не нужен\n<базовый URL> --POST--> {<номер-фрагмента>:{<номер-блока>: \'новое значение (это HTML-код)\', <другой-номер-блока>: \'новое значение\'}, <другой-номер-фрагмента>:{...}}. Эти изменения будут сохранены',
    options:{
        $editable: 'флаг редактируемости. Если в процессе работы редактируемость может меняться, то не указывайте в опциях, а управляйте редактируемостью через объект состояния',
        $fragmentsApiRequest: '(строка) функция из Traliva.api, которая инициирует запрос на сервер для получения текста (HTML). Принимаемые параметры: идентификатор текста, идентификатор фрагмента.',
        $fragmentApiResponse: '(строка) функция из Traliva.api, которая будет вызываться, когда ответ от сервера придёт. Этот компонент переопределит эту функцию, и сам будет получать данные от сервера. Ожидаемый формат ответа:\n[\'Первый блок (это HTML-код)\', \'Второй блок (это HTML-код)\']',
    },
    stateObj:{
        $editable: 'флаг редактируемости. Если указано значение соответствующего атрибута в опциях, то будет игнорироваться',
        $current: 'текущие текст, фрагмент и блок. при прокрутке пользователем меняется, при внешнем изменении меняется текущая позиция в тексте, при изменении геометрии экрана контент отображается, начиная от начала определённого в этом свойстве блока. Задаётся в виде объекта: {$textId: 45, $fragment: 0, $block: 0} ($fragment и $block имеют значение 0 по умолчанию).',
        $fragmentsCount: 'общее количество фрагментов в тексте',
        $textCorrection: 'здесь хранятся изменения в тексте, произведённые пользователем. Эти изменения могут быть считаны внешними компонентами для сохранения на сервер. После успешного сохранения следует соответствующее поле добавить в свойство $textCorrectionApplied (см. далее), чтобы данный компонент сам убрал данные об изменённости',
        $textRefragmentation: 'сюда записываются команды от внешнего "сохраняльщика" на перефрагментацию текста. Пример команды: D1:',
        $textCorrectionApplied: 'сюда следует записывать сохранённые блоки. Этот компонент сравнит, не изменились ли они за время сохранения, и если они не изменилисб, то сведения об изменённости блоков будут подчищены',
        $fGetFragmentData: '(функция) Эту функцию добавляет сам данный компонент. Она нужна внешнему компоненту для сохранения изменений. Эта функция даёт данные по идентификатору фрагмента.'
    }
});
#USAGE_END#traliva_kit_debug##
function $LargeTextEdit($p_wContainer, $p_options){
    $Traliva.$WidgetStateSubscriber.call(this, $p_wContainer, $p_options);
    this.$options = $p_options;
    // ...
}
$LargeTextEdit.prototype = Object.create($Traliva.$WidgetStateSubscriber.prototype);
$LargeTextEdit.prototype.constructor = $LargeTextEdit;
$LargeTextEdit.prototype.$processStateChanges = function(s){
    if (!s){
        console.error('epic fail');
        return;
    }
    // ...
}
